<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Cirkel verdelen in taartpunten</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #000000;
      font-family: "Kermit", Arial, sans-serif;
    }

    #circleCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: #000000;
    }

    .controls {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 20;
      background: rgba(255, 255, 255, 0.97);
      border: 1px solid #cccccc;
      border-radius: 12px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 13px;
      width: 360px;
      max-height: calc(100vh - 20px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      font-family: inherit;
    }

    .controls h2 {
      margin: 0 0 4px 0;
      font-size: 15px;
      font-weight: 600;
    }

    .controls h3 {
      margin: 4px 0 2px 0;
      font-size: 13px;
      font-weight: 600;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 2px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .controls input[type="number"] {
      width: 80px;
      padding: 4px;
      font-size: 13px;
      font-family: inherit;
    }

    .controls input[type="text"] {
      flex: 1;
      padding: 4px;
      font-size: 13px;
      font-family: inherit;
    }

    .controls button {
      padding: 4px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid #333333;
      background: #f5f5f5;
      transition: transform 0.05s ease, box-shadow 0.05s ease, filter 0.1s ease;
      font-family: inherit;
    }

    .controls button:hover {
      filter: brightness(0.96);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }

    .controls button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .toggle-option {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }

    .hint {
      font-size: 11px;
      color: #555555;
    }

    .word-list-container {
      border: 1px solid #dddddd;
      border-radius: 8px;
      padding: 6px;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 4px;
      flex: 1;
      min-height: 60px;
    }

    .word-list-header {
      font-size: 12px;
      font-weight: 600;
      color: #333333;
    }

    .word-list {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 140px;
      overflow-y: auto;
      font-size: 12px;
    }

    .word-list li {
      padding: 3px 6px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .word-list li:nth-child(odd) {
      background: #f0f0f0;
    }

    .word-list li:nth-child(even) {
      background: #ffffff;
    }

    .word-list li:hover {
      background: #ffe0e0;
    }

    .word-index {
      font-size: 10px;
      color: #777777;
      margin-right: 6px;
    }

    /* Help overlay */
    #helpOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      font-family: inherit;
    }

    #helpBox {
      background: #ffffff;
      border-radius: 12px;
      padding: 16px 18px;
      max-width: 520px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
      font-size: 13px;
      font-family: inherit;
    }

    #helpBox h2 {
      margin-top: 0;
      margin-bottom: 6px;
      font-size: 16px;
    }

    #helpBox ul {
      padding-left: 18px;
      margin-top: 4px;
      margin-bottom: 8px;
    }

    #closeHelpBtn {
      margin-top: 10px;
      display: inline-block;
    }

    .footer {
      font-size: 11px;
      color: #777777;
      text-align: center;
      margin-top: 4px;
      padding-top: 4px;
      border-top: 1px solid #e0e0e0;
    }

    .footer a {
      color: #0077cc;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    select {
      font-family: inherit;
      font-size: 12px;
      padding: 3px;
      max-width: 100%;
    }
  </style>
</head>
<body>

  <div class="controls">
    <div class="row" style="justify-content: space-between;">
      <h2>Cirkel instellen</h2>
      <button id="helpBtn">Uitleg</button>
    </div>

    <div class="row">
      <label for="pointsInput">Aantal punten:</label>
      <input type="number" id="pointsInput" min="1" value="24" />
    </div>

    <div class="row">
      <button id="generateBtn">Genereer</button>
      <button id="saveBtn">Sla op</button>
    </div>

    <h3>Lettertype</h3>
    <div class="row">
      <label for="fontSelect">Kies lettertype:</label>
      <select id="fontSelect">
        <option value="kermit">Kermit (indien beschikbaar)</option>
        <option value="arial">Arial</option>
        <option value="comic">Comic Sans MS</option>
        <option value="verdana">Verdana</option>
        <option value="poppins">Poppins</option>
        <option value="glacial">Glacial Indifference</option>
        <option value="questrial">Questrial</option>
        <option value="bree">Bree Serif</option>
        <option value="codec">Codec Pro</option>
        <option value="now">Now</option>
        <option value="quicksand">Quicksand</option>
        <option value="cocomat">Cocomat Pro</option>
        <option value="mandani">Mandani Arabic</option>
      </select>
    </div>

    <h3>Kleurmodus</h3>
    <div id="colorModeGroup">
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="white" checked />
        Witte cirkel
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="rainbow" />
        Regenboog
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="blue" />
        Lichtblauw en wit
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="yellow" />
        Geel en lichtgeel
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="green" />
        Groen en lichtgroen
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="pastel1" />
        Zacht roze en lichtgrijs
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="pastel2" />
        Zacht blauw en zacht groen
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="sand" />
        Zandkleur en licht zand
      </label>
    </div>

    <h3>Achtergrond</h3>
    <label class="toggle-option">
      <input type="checkbox" id="transparentCheckbox" />
      Transparant bij opslaan (PNG)
    </label>

    <h3>Woorden</h3>
    <div class="row">
      <input type="text" id="wordInput" placeholder="Nieuw woord" />
      <button id="addWordBtn">Voeg toe</button>
    </div>

    <div class="row">
      <label for="textFileInput">Upload lijst (.txt)</label>
      <input type="file" id="textFileInput" accept=".txt" />
    </div>

    <div class="word-list-container">
      <div class="word-list-header">Woorden in de cirkel (klik om te verwijderen):</div>
      <ul id="wordList" class="word-list"></ul>
    </div>

    <div class="hint">
      - Elke regel in het tekstbestand wordt een eigen taartpunt.  
      - Als er woorden zijn, volgt het aantal punten altijd het aantal woorden.  
      - Je kunt ook op een taartpunt in de cirkel klikken om het woord te verwijderen.
    </div>

    <div class="footer">
      Gemaakt door
      <a href="https://www.edubolt.nl/" target="_blank" rel="noopener noreferrer">
        EduBOLT
      </a>.
    </div>
  </div>

  <!-- Help overlay -->
  <div id="helpOverlay">
    <div id="helpBox">
      <h2>Uitleg cirkel app</h2>
      <p>Met deze app maak je een cirkel verdeeld in gelijke taartpunten, met kleuren en woorden langs de buitenrand.</p>
      <ul>
        <li><strong>Aantal punten</strong>: aantal segmenten als er geen woorden zijn. Als er woorden zijn, bepaalt de lijst met woorden het aantal punten.</li>
        <li><strong>Genereer</strong>: tekent of ververst de cirkel met de huidige instellingen.</li>
        <li><strong>Sla op</strong>: slaat een vierkante afbeelding op. Bij transparant vinkje is dit een PNG met transparante buitenrand, anders een JPG met witte achtergrond.</li>
        <li><strong>Lettertype</strong>: kies welk lettertype wordt gebruikt in het menu en in het rad. Werkt alleen als het lettertype op het apparaat aanwezig is.</li>
        <li><strong>Kleurmodus</strong>: kies de kleurstelling van de taartpunten. De woorden blijven gelijk.</li>
        <li><strong>Transparant bij opslaan</strong>: bepaalt of de opgeslagen afbeelding een transparante achtergrond heeft. Op het scherm blijft de achtergrond zwart.</li>
        <li><strong>Nieuw woord + Voeg toe</strong>: voeg een woord toe als extra taartpunt. Enter in het tekstvak werkt ook.</li>
        <li><strong>Upload lijst (.txt)</strong>: elke niet lege regel wordt een woord en dus een eigen taartpunt.</li>
        <li><strong>Woordenlijst</strong>: klik op een woord om het te verwijderen.</li>
        <li><strong>Cirkel zelf</strong>: klik op een taartpunt om het bijbehorende woord te verwijderen.</li>
      </ul>
      <button id="closeHelpBtn">Sluiten</button>
    </div>
  </div>

  <canvas id="circleCanvas"></canvas>

  <script>
    const canvas = document.getElementById("circleCanvas");
    const ctx = canvas.getContext("2d");

    const pointsInput = document.getElementById("pointsInput");
    const generateBtn = document.getElementById("generateBtn");
    const saveBtn = document.getElementById("saveBtn");
    const transparentCheckbox = document.getElementById("transparentCheckbox");
    const textFileInput = document.getElementById("textFileInput");
    const wordInput = document.getElementById("wordInput");
    const addWordBtn = document.getElementById("addWordBtn");
    const colorModeGroup = document.getElementById("colorModeGroup");
    const wordListElement = document.getElementById("wordList");
    const helpBtn = document.getElementById("helpBtn");
    const helpOverlay = document.getElementById("helpOverlay");
    const closeHelpBtn = document.getElementById("closeHelpBtn");
    const fontSelect = document.getElementById("fontSelect");
    const controls = document.querySelector(".controls");
    const helpBox = document.getElementById("helpBox");

    let useTransparentBackground = false;
    let colorMode = "white";
    let labels = [];
    let currentFontStack = '"Kermit", Arial, sans-serif';

    function applyFontStack() {
      document.body.style.fontFamily = currentFontStack;
      controls.style.fontFamily = currentFontStack;
      helpOverlay.style.fontFamily = currentFontStack;
      if (helpBox) helpBox.style.fontFamily = currentFontStack;
      drawCircle();
    }

    fontSelect.addEventListener("change", () => {
      const value = fontSelect.value;
      switch (value) {
        case "kermit":
          currentFontStack = '"Kermit", Arial, sans-serif';
          break;
        case "arial":
          currentFontStack = 'Arial, sans-serif';
          break;
        case "comic":
          currentFontStack = '"Comic Sans MS", Arial, sans-serif';
          break;
        case "verdana":
          currentFontStack = 'Verdana, Arial, sans-serif';
          break;
        case "poppins":
          currentFontStack = '"Poppins", Arial, sans-serif';
          break;
        case "glacial":
          currentFontStack = '"Glacial Indifference", Arial, sans-serif';
          break;
        case "questrial":
          currentFontStack = '"Questrial", Arial, sans-serif';
          break;
        case "bree":
          currentFontStack = '"Bree Serif", serif';
          break;
        case "codec":
          currentFontStack = '"Codec Pro", Arial, sans-serif';
          break;
        case "now":
          currentFontStack = '"Now", Arial, sans-serif';
          break;
        case "quicksand":
          currentFontStack = '"Quicksand", Arial, sans-serif';
          break;
        case "cocomat":
          currentFontStack = '"Cocomat Pro", Arial, sans-serif';
          break;
        case "mandani":
          currentFontStack = '"Mandani Arabic", Arial, sans-serif';
          break;
        default:
          currentFontStack = '"Kermit", Arial, sans-serif';
      }
      applyFontStack();
    });

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawCircle();
    }
    window.addEventListener("resize", resizeCanvas);

    transparentCheckbox.addEventListener("change", () => {
      useTransparentBackground = transparentCheckbox.checked;
      drawCircle();
    });

    colorModeGroup.addEventListener("change", (event) => {
      if (event.target.name === "colorMode") {
        colorMode = event.target.value;
        drawCircle();
      }
    });

    textFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        labels = e.target.result
          .split(/\r?\n/)
          .map(l => l.trim())
          .filter(l => l);

        if (labels.length > 0) {
          pointsInput.value = labels.length;
        }
        renderWordList();
        drawCircle();
      };
      reader.readAsText(file, "utf-8");
    });

    function addWord() {
      const t = wordInput.value.trim();
      if (!t) return;
      labels.push(t);
      pointsInput.value = labels.length;
      wordInput.value = "";
      renderWordList();
      drawCircle();
    }

    addWordBtn.addEventListener("click", addWord);
    wordInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        addWord();
      }
    });

    function getSegmentCount() {
      if (labels.length > 0) {
        return labels.length;
      }
      const n = parseInt(pointsInput.value, 10);
      return Number.isFinite(n) && n > 0 ? n : 1;
    }

    function getColorsForMode(i) {
      if (colorMode === "white") return "#ffffff";

      if (colorMode === "rainbow") {
        const c = ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#8B00FF"];
        return c[i % c.length];
      }

      if (colorMode === "blue") {
        return i % 2 === 0 ? "#ADD8E6" : "#FFFFFF";
      }

      if (colorMode === "yellow") {
        return i % 2 === 0 ? "#FFD700" : "#FFFACD";
      }

      if (colorMode === "green") {
        return i % 2 === 0 ? "#90EE90" : "#E0FFE0";
      }

      if (colorMode === "pastel1") {
        return i % 2 === 0 ? "#F8C8DC" : "#E0E0E0";
      }

      if (colorMode === "pastel2") {
        return i % 2 === 0 ? "#B3D4FF" : "#BEE7C8";
      }

      if (colorMode === "sand") {
        return i % 2 === 0 ? "#D2B48C" : "#F0E6D2";
      }

      return "#ffffff";
    }

    function drawCircle() {
      const n = getSegmentCount();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#000000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const dim = Math.min(canvas.width, canvas.height);
      const offsetX = (canvas.width - dim) / 2;
      const offsetY = (canvas.height - dim) / 2;
      const cx = offsetX + dim / 2;
      const cy = offsetY + dim / 2;
      const radius = dim / 2 - 10;

      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000000";

      for (let i = 0; i < n; i++) {
        const start = (i / n) * Math.PI * 2;
        const end = ((i + 1) / n) * Math.PI * 2;

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, start, end);
        ctx.closePath();
        ctx.fillStyle = getColorsForMode(i);
        ctx.fill();
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();

      if (labels.length > 0) {
        for (let i = 0; i < n; i++) {
          const text = labels[i] || "";
          drawCurvedWord(ctx, text, i, n, cx, cy, radius);
        }
      }
    }

    function drawCurvedWord(context, text, index, n, cx, cy, radius) {
      if (!text) return;

      const startAngle = (index / n) * Math.PI * 2;
      const endAngle = ((index + 1) / n) * Math.PI * 2;
      const wedgeAngle = endAngle - startAngle;
      const midAngle = (startAngle + endAngle) / 2;

      const textRadius = radius * 0.88;
      let baseSize = Math.max(10, radius * 0.12);
      context.save();
      context.font = `${baseSize}px bold ${currentFontStack}`;
      const metrics = context.measureText(text);
      const textWidth = metrics.width || 1;

      const targetArcLength = wedgeAngle * textRadius * 0.9;
      let scaleFactor = targetArcLength / textWidth;

      if (scaleFactor > 2) scaleFactor = 2;
      if (scaleFactor < 0.4) scaleFactor = 0.4;

      let fontSize = baseSize * scaleFactor;
      fontSize = Math.min(fontSize, radius * 0.22);
      fontSize = Math.max(fontSize, 10);

      context.font = `${fontSize}px bold ${currentFontStack}`;

      const chars = [...text];
      const charWidths = chars.map(ch => context.measureText(ch).width);
      const totalWidth = charWidths.reduce((a, b) => a + b, 0) || 1;

      context.translate(cx, cy);

      let currentOffset = -totalWidth / 2;

      for (let i = 0; i < chars.length; i++) {
        const ch = chars[i];
        const w = charWidths[i];
        const charCenterOffset = currentOffset + w / 2;

        const angleOffset = charCenterOffset / textRadius;
        const charAngle = midAngle + angleOffset;

        context.save();
        context.rotate(charAngle + Math.PI / 2);
        context.translate(0, -textRadius);
        context.fillStyle = "#000000";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText(ch, 0, 0);
        context.restore();

        currentOffset += w;
      }

      context.restore();
    }

    function drawExportImage(ctxExp, size, transparent) {
      const cx = size / 2;
      const cy = size / 2;
      const radius = size / 2 - 10;
      const n = getSegmentCount();

      if (!transparent) {
        ctxExp.fillStyle = "#ffffff";
        ctxExp.fillRect(0, 0, size, size);
      } else {
        ctxExp.clearRect(0, 0, size, size);
      }

      ctxExp.lineWidth = 2;
      ctxExp.strokeStyle = "#000000";

      for (let i = 0; i < n; i++) {
        const start = (i / n) * Math.PI * 2;
        const end = ((i + 1) / n) * Math.PI * 2;

        ctxExp.beginPath();
        ctxExp.moveTo(cx, cy);
        ctxExp.arc(cx, cy, radius, start, end);
        ctxExp.closePath();
        ctxExp.fillStyle = getColorsForMode(i);
        ctxExp.fill();
        ctxExp.stroke();
      }

      ctxExp.beginPath();
      ctxExp.arc(cx, cy, radius, 0, Math.PI * 2);
      ctxExp.stroke();

      if (labels.length > 0) {
        for (let i = 0; i < n; i++) {
          const text = labels[i] || "";
          drawCurvedWord(ctxExp, text, i, n, cx, cy, radius);
        }
      }
    }

    saveBtn.addEventListener("click", () => {
      const n = getSegmentCount();
      if (!Number.isFinite(n) || n < 1) return;

      const size = Math.min(window.innerWidth, window.innerHeight);
      const outCanvas = document.createElement("canvas");
      outCanvas.width = size;
      outCanvas.height = size;
      const outCtx = outCanvas.getContext("2d");

      drawExportImage(outCtx, size, useTransparentBackground);

      const link = document.createElement("a");
      if (useTransparentBackground) {
        link.download = "cirkel.png";
        link.href = outCanvas.toDataURL("image/png");
      } else {
        link.download = "cirkel.jpg";
        link.href = outCanvas.toDataURL("image/jpeg", 0.95);
      }
      link.click();
    });

    canvas.addEventListener("click", (e) => {
      if (labels.length === 0) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      const dim = Math.min(canvas.width, canvas.height);
      const offsetX = (canvas.width - dim) / 2;
      const offsetY = (canvas.height - dim) / 2;
      const cx = offsetX + dim / 2;
      const cy = offsetY + dim / 2;
      const radius = dim / 2 - 10;

      const dx = x - cx;
      const dy = y - cy;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > radius) return;

      let angle = Math.atan2(dy, dx);
      if (angle < 0) angle += Math.PI * 2;

      const seg = labels.length;
      const sliceAngle = (Math.PI * 2) / seg;
      const index = Math.floor(angle / sliceAngle);

      if (index >= 0 && index < labels.length) {
        labels.splice(index, 1);
        pointsInput.value = labels.length;
        renderWordList();
        drawCircle();
      }
    });

    function renderWordList() {
      wordListElement.innerHTML = "";
      labels.forEach((word, index) => {
        const li = document.createElement("li");
        const spanIndex = document.createElement("span");
        spanIndex.className = "word-index";
        spanIndex.textContent = index + 1;
        const spanText = document.createElement("span");
        spanText.textContent = word;

        li.appendChild(spanIndex);
        li.appendChild(spanText);
        li.dataset.index = index.toString();

        li.addEventListener("click", () => {
          const idx = parseInt(li.dataset.index, 10);
          if (!Number.isNaN(idx)) {
            labels.splice(idx, 1);
            pointsInput.value = labels.length;
            renderWordList();
            drawCircle();
          }
        });

        wordListElement.appendChild(li);
      });
    }

    helpBtn.addEventListener("click", () => {
      helpOverlay.style.display = "flex";
    });

    closeHelpBtn.addEventListener("click", () => {
      helpOverlay.style.display = "none";
    });

    helpOverlay.addEventListener("click", (e) => {
      if (e.target === helpOverlay) {
        helpOverlay.style.display = "none";
      }
    });

    generateBtn.addEventListener("click", drawCircle);
    pointsInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        drawCircle();
      }
    });

    renderWordList();
    resizeCanvas();
    applyFontStack();
  </script>
</body>
</html>
