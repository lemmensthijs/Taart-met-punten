<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <title>Cirkel verdelen in taartpunten</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #ffffff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #circleCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .controls {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255, 255, 255, 0.97);
      border: 1px solid #cccccc;
      border-radius: 12px;
      padding: 12px 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      font-size: 13px;
      width: 280px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .controls h2 {
      margin: 0 0 4px 0;
      font-size: 15px;
      font-weight: 600;
    }

    .controls h3 {
      margin: 4px 0 2px 0;
      font-size: 13px;
      font-weight: 600;
      border-bottom: 1px solid #e0e0e0;
      padding-bottom: 2px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .row label {
      white-space: nowrap;
    }

    .controls input[type="number"] {
      width: 80px;
      padding: 4px;
      font-size: 13px;
    }

    .controls input[type="text"] {
      flex: 1;
      padding: 4px;
      font-size: 13px;
    }

    .controls button {
      padding: 4px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 6px;
      border: 1px solid #333333;
      background: #f5f5f5;
      transition: transform 0.05s ease, box-shadow 0.05s ease, filter 0.1s ease;
    }

    .controls button:hover {
      filter: brightness(0.96);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
    }

    .controls button:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .toggle-option {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
    }

    .controls input[type="file"] {
      font-size: 12px;
    }

    .hint {
      font-size: 11px;
      color: #555555;
    }
  </style>
</head>
<body>
  <div class="controls">
    <h2>Cirkel instellen</h2>

    <div class="row">
      <label for="pointsInput">Aantal punten:</label>
      <input type="number" id="pointsInput" min="1" value="24" />
    </div>

    <div class="row">
      <button id="generateBtn">Genereer</button>
      <button id="saveBtn">Sla op</button>
    </div>

    <h3>Kleurmodus</h3>
    <div class="toggle-group" id="colorModeGroup">
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="white" checked />
        Witte cirkel
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="rainbow" />
        Regenboog cirkel
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="blue" />
        Lichtblauw en wit om en om
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="yellow" />
        Geel en lichtgeel om en om
      </label>
      <label class="toggle-option">
        <input type="radio" name="colorMode" value="green" />
        Groen en lichtgroen om en om
      </label>
    </div>

    <h3>Achtergrond</h3>
    <div class="row">
      <input type="checkbox" id="transparentCheckbox" />
      <label for="transparentCheckbox">Achtergrond transparant (PNG)</label>
    </div>

    <h3>Woorden</h3>
    <div class="row">
      <input type="text" id="wordInput" placeholder="Nieuw woord" />
      <button id="addWordBtn">Voeg toe</button>
    </div>
    <div class="row">
      <label for="textFileInput">Lijst uploaden (.txt)</label>
      <input type="file" id="textFileInput" accept=".txt" />
    </div>
    <div class="hint">
      • Elke regel in het tekstbestand wordt een taartpunt.  
      • Klik op een taartpunt om het woord te verwijderen.
    </div>
  </div>

  <canvas id="circleCanvas"></canvas>

  <script>
    const canvas = document.getElementById("circleCanvas");
    const ctx = canvas.getContext("2d");

    const pointsInput = document.getElementById("pointsInput");
    const generateBtn = document.getElementById("generateBtn");
    const saveBtn = document.getElementById("saveBtn");
    const transparentCheckbox = document.getElementById("transparentCheckbox");
    const textFileInput = document.getElementById("textFileInput");
    const wordInput = document.getElementById("wordInput");
    const addWordBtn = document.getElementById("addWordBtn");
    const colorModeGroup = document.getElementById("colorModeGroup");

    let useTransparentBackground = false;
    let labels = [];
    let colorMode = "white";

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      drawCircle();
    }

    window.addEventListener("resize", resizeCanvas);

    transparentCheckbox.addEventListener("change", () => {
      useTransparentBackground = transparentCheckbox.checked;
      drawCircle();
    });

    colorModeGroup.addEventListener("change", (event) => {
      if (event.target.name === "colorMode") {
        colorMode = event.target.value;
        drawCircle();
      }
    });

    textFileInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) {
        return;
      }
      const reader = new FileReader();
      reader.onload = (e) => {
        const content = e.target.result;
        labels = content
          .split(/\r?\n/)
          .map(line => line.trim())
          .filter(line => line.length > 0);

        if (labels.length > 0) {
          pointsInput.value = labels.length;
        }
        drawCircle();
      };
      reader.readAsText(file, "utf-8");
    });

    function addWordFromInput() {
      const text = wordInput.value.trim();
      if (text.length === 0) {
        return;
      }
      labels.push(text);
      pointsInput.value = labels.length;
      wordInput.value = "";
      drawCircle();
    }

    addWordBtn.addEventListener("click", addWordFromInput);

    wordInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        addWordFromInput();
      }
    });

    function getSegmentCount() {
      if (labels.length > 0) {
        return labels.length;
      }
      const n = parseInt(pointsInput.value, 10);
      if (!Number.isFinite(n) || n < 1) {
        return 1;
      }
      return n;
    }

    function getColorsForMode(index) {
      if (colorMode === "white") {
        return "#ffffff";
      }

      if (colorMode === "rainbow") {
        const rainbow = [
          "#FF0000",
          "#FF7F00",
          "#FFFF00",
          "#00FF00",
          "#0000FF",
          "#4B0082",
          "#8B00FF"
        ];
        return rainbow[index % rainbow.length];
      }

      if (colorMode === "blue") {
        return index % 2 === 0 ? "#ADD8E6" : "#FFFFFF";
      }

      if (colorMode === "yellow") {
        return index % 2 === 0 ? "#FFD700" : "#FFFACD";
      }

      if (colorMode === "green") {
        return index % 2 === 0 ? "#90EE90" : "#E0FFE0";
      }

      return "#ffffff";
    }

    function drawCircle() {
      const n = getSegmentCount();

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const dim = Math.min(canvas.width, canvas.height);
      const offsetX = (canvas.width - dim) / 2;
      const offsetY = (canvas.height - dim) / 2;
      const cx = offsetX + dim / 2;
      const cy = offsetY + dim / 2;
      const radius = dim / 2 - 10;

      if (!useTransparentBackground) {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.lineWidth = 2;
      ctx.strokeStyle = "#000000";

      // Taartpunten tekenen
      for (let i = 0; i < n; i++) {
        const startAngle = (i / n) * Math.PI * 2;
        const endAngle = ((i + 1) / n) * Math.PI * 2;
        const color = getColorsForMode(i);

        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius, startAngle, endAngle);
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        ctx.stroke();
      }

      // Rand cirkel
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.stroke();

      // Woorden aan de buitenkant
      if (n > 0 && labels.length > 0) {
        for (let i = 0; i < n; i++) {
          const text = labels[i % labels.length];
          drawWordInSlice(ctx, text, i, n, cx, cy, radius);
        }
      }
    }

    function drawWordInSlice(context, text, index, segments, cx, cy, radius) {
      if (!text || text.length === 0) {
        return;
      }

      const startAngle = (index / segments) * Math.PI * 2;
      const endAngle = ((index + 1) / segments) * Math.PI * 2;
      const midAngle = (startAngle + endAngle) / 2;

      const textRadius = radius * 0.88; // vlak bij de rand
      const wedgeWidth = (endAngle - startAngle) * textRadius;

      // Eerste schatting voor lettergrootte
      let baseSize = Math.max(12, radius * 0.12);
      context.save();
      context.font = `bold ${baseSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;
      const measured = context.measureText(text);
      const textWidth = measured.width || 1;

      const targetWidth = wedgeWidth * 0.9;
      const factor = targetWidth / textWidth;
      let fontSize = baseSize * factor;

      fontSize = Math.max(10, Math.min(fontSize, radius * 0.2));

      context.font = `bold ${fontSize}px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif`;

      context.translate(cx, cy);
      context.rotate(midAngle + Math.PI / 2);
      context.translate(0, -textRadius);

      context.fillStyle = "#000000";
      context.textAlign = "center";
      context.textBaseline = "middle";

      context.fillText(text, 0, 0);

      context.restore();
    }

    function drawSquareExport(ctxExport, size, segments) {
      ctxExport.clearRect(0, 0, size, size);

      const cx = size / 2;
      const cy = size / 2;
      const radius = size / 2 - 10;

      if (!useTransparentBackground) {
        ctxExport.fillStyle = "#ffffff";
        ctxExport.fillRect(0, 0, size, size);
      }

      ctxExport.lineWidth = 2;
      ctxExport.strokeStyle = "#000000";

      for (let i = 0; i < segments; i++) {
        const startAngle = (i / segments) * Math.PI * 2;
        const endAngle = ((i + 1) / segments) * Math.PI * 2;
        const color = getColorsForMode(i);

        ctxExport.beginPath();
        ctxExport.moveTo(cx, cy);
        ctxExport.arc(cx, cy, radius, startAngle, endAngle);
        ctxExport.closePath();
        ctxExport.fillStyle = color;
        ctxExport.fill();
        ctxExport.stroke();
      }

      ctxExport.beginPath();
      ctxExport.arc(cx, cy, radius, 0, Math.PI * 2);
      ctxExport.stroke();

      if (segments > 0 && labels.length > 0) {
        for (let i = 0; i < segments; i++) {
          const text = labels[i % labels.length];
          drawWordInSlice(ctxExport, text, i, segments, cx, cy, radius);
        }
      }
    }

    generateBtn.addEventListener("click", drawCircle);

    pointsInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        drawCircle();
      }
    });

    saveBtn.addEventListener("click", () => {
      const segments = getSegmentCount();
      if (!Number.isFinite(segments) || segments < 1) {
        return;
      }

      const size = Math.min(window.innerWidth, window.innerHeight);
      const exportCanvas = document.createElement("canvas");
      exportCanvas.width = size;
      exportCanvas.height = size;
      const exportCtx = exportCanvas.getContext("2d");

      drawSquareExport(exportCtx, size, segments);

      const link = document.createElement("a");

      const safeN = Number.isFinite(segments) && segments > 0 ? segments : "onbekend";

      if (useTransparentBackground) {
        link.download = `cirkel_${safeN}_punten.png`;
        link.href = exportCanvas.toDataURL("image/png");
      } else {
        link.download = `cirkel_${safeN}_punten.jpg`;
        link.href = exportCanvas.toDataURL("image/jpeg", 0.95);
      }

      link.click();
    });

    // Klik op taartpunt om woord te verwijderen
    canvas.addEventListener("click", (event) => {
      if (labels.length === 0) {
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;

      const dim = Math.min(canvas.width, canvas.height);
      const offsetX = (canvas.width - dim) / 2;
      const offsetY = (canvas.height - dim) / 2;
      const cx = offsetX + dim / 2;
      const cy = offsetY + dim / 2;
      const radius = dim / 2 - 10;

      const dx = clickX - cx;
      const dy = clickY - cy;
      const distance = Math.sqrt(dx * dx + dy * dy);

      if (distance > radius) {
        return;
      }

      let angle = Math.atan2(dy, dx);
      if (angle < 0) {
        angle += Math.PI * 2;
      }

      const segments = labels.length;
      const sliceAngle = (Math.PI * 2) / segments;
      const index = Math.floor(angle / sliceAngle);

      if (index >= 0 && index < labels.length) {
        labels.splice(index, 1);
        if (labels.length > 0) {
          pointsInput.value = labels.length;
        }
        drawCircle();
      }
    });

    resizeCanvas();
  </script>
</body>
</html>
